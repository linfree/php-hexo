---
title: Python，Re模块的学习
date: 2017-05-20 20:07:31
tags:
  - Python
  - 正则表达式
desc: Python，Re模块的学习
keywords: Python Re 正则表达式 学习 笔记
categories:
- Python

---



## 1.概念：

正则表达式（或 RE）是一种小型的、高度专业化的编程语言，在Python中）它内嵌在Python中，并通过 re 模块实现。
使用这个小型语言，你可以为想要匹配的相应字符串集指定规则；
该字符串集可能包含英文语句、email、地址、TeX命令或任何你想搞定的东西。
然后你可以问诸如“这个字符串匹配该模式吗？”或“在这个字符串中是否有部分匹配该模式呢？”。
你也可以使用 RE以各种方式来修改或分割字符串。正则表达式语言相对小型和受限（功能有限），
因此并非所有字符串处理都能用正则表达式完成。
当然也有些任务可以用正则表达式完成，不过最终表达式会变得异常复杂。
碰到这些情形时，编写 Python 代码进行处理可能反而更好；
尽管Python 代码比一个精巧的正则表达式要慢些，但它更易理解。
<!--more-->
## 2.在正则表达式中， 如下的字符是具有特殊含义的
```
. (所有字符)  ^  $  *(0-N次)  +(1-N次)  ? (0-1次) { } [  ]  \  |  ( ) 

```
1)."[" 和 "]"。它们常用来指定一个字符类别，所谓字符类别就是你想匹配的一个字符集

2).其它地方的"^"只会简单匹配 "^"字符本身。例[^5] 将匹配除 "5" 之外的任意字符。

3).反斜杠后面可以加不同的字符以表示不同特殊意义。它也可以用于取消所有的元字符


## 3.RE 函数用法:
   findall(rule , target [,flag] ) 在目标字符串中查找符合规则的字符串。
   match() 决定 RE 是否在字符串刚开始的位置匹配
   search() 扫描字符串，找到这个 RE 匹配的位置
   findall() 找到 RE 匹配的所有子串，并把它们作为一个列表返回
   finditer() 找到 RE 匹配的所有子串，并把它们作为一个迭代器返回
   group() 返回被 RE 匹配的字符串
   start() 返回匹配开始的位置
   end() 返回匹配结束的位置
   span() 返回一个元组包含匹配 (开始,结束) 的位置
   compile( rule [,flag] )将正则规则编译成一个Pattern对象，以供接下来使用第一个参数是规则式，第二个参数是规则选项。(使用compile加速)

## 4 : 含义:

	预定义转义字符集： “\d”  “\w” “\s” 等等，它们是以字符’\’开头，后面接一个特定字符的形式,用来指示一个预定义好的含义

	‘^’  和’$’ 匹配字符串开头和结尾
	‘.’    匹配所有字符 除\n以外
	‘\d’  匹配数字
	‘\D’  匹配非数字
	‘\w’  匹配字母和数字
	‘\W’  匹配非英文字母和数字
	‘\s’   匹配间隔符
	‘\S’   匹配非间隔符
	‘\A’  匹配字符串开头
	‘\Z’  匹配字符串结尾
	‘\b’  只用以匹配单词的词首和词尾。单词被定义为一个字母数字序列，因此词尾就是用空白符或非字母数字符来标示的。(退格)
	‘\B’，它正好同 \b 相反，只在当前位置不在单词边界时匹配。

## 5.前向界定与后向界定:

	‘(?<=…)’ 前向界定:括号中’…’代表你希望匹配的字符串的前面应该出现的字符串。
	‘(?=…)’后向界定    :括号中的’…’代表你希望匹配的字符串后面应该出现的字符串
	‘(?<!..)’前向非界定 :只有当你希望的字符串前面不是’…’的内容时才匹配
	‘(?!...)’后向非界定  :只有当你希望的字符串后面不跟着’…’内容时才匹配。

## 6.组的基本知识:
	‘(‘’)’          无命名组                    [a-z]+(\d+)[a-z]+
	‘(?P<name>…)’    命名组                    (?P<g1>[a-z]+)\d+(?P=g1)
	‘(?P=name)’    调用已匹配的命名组
	‘\number’     通过序号调用已匹配的组正则式中的每个组都有一个序号，序号是按组从左到右，从1开始的数字，你可以通过下面的形式来调用已匹配的组 ( r"(\d+)([a-z]+)(\d+)(\2)(\1)" )  

```
# -*- coding:UTF8 -*- 
import sys
reload(sys)
sys.setdefaultencoding('utf-8')

import rhinoscriptsyntax as rs
# 正则表达式
import re
str1 = "abc \\ 123 456"
print re.findall("\\\\",str1)  # 不用r和用r的区
print re.findall(r"\d\Z",str1) # 用"r"来定义规则字符串

p = re.compile('(a)b')
m = p.match('ab')
print m.group()

s = "aaa1 22 gg 333 ccc 4444 pppp 55555 666"
print re.findall(r"\b\d{3}\b",s)
print re.findall(r"\b\d{2,4}\b",s)

s2 = "aaa111aaa , bbb222 , 333ccc"
print re.findall( r"(?<=[a-z]+)\d+(?=[a-z]+)",s2 )
print re.findall( r"\d+(?=[a-z]+)",s2 )
## 目标 前面是a-z 1-多次、中间数字1-9 1-多次
print re.findall(r"\d+(?!\w+)",s2)
#无命名组
print re.findall(r"[a-z]+(\d+)[a-z]+",s2) # 只返回()里面的
s3 = 'aaa111aaa,bbb222,333ccc,444ddd444,555eee666,fff777ggg,hhh888hhh'
print re.findall(r"([a-z]+)\d+([a-z]+)",s3) #返回括号里面的
#‘(?P<name>…)’ 命名组
print re.findall( r"(?P<g1>[a-z]+)\d+(?P=g1)",s3 ) #找出被中间夹有数字的前后同样的字母
print re.findall(r"([a-z]+)\d+\1",s3)
s4 = "111aaa222aaa111,333bbb444bb33"
print re.findall( r"(\d+)([a-z]+)(\d+)(\2)(\1)", s4 ) #数字、字母、数字、字母、数字相对称
print re.compile(r"(\d+)([a-z]+)(\d+)(\2)(\1)").findall(s4)

#compile( rule [,flag] ) 使用compile加速
s5 = "111,222,aaa,bbb,ccc333,444ddd"
print re.compile(r"\d+\b").findall(s5) # \退格 匹配一个位于开头的数字，没有使用M选项

s6 = "123 456\n789 012\n345 678"
print re.compile(r"^\d+",re.M).findall(s6) # 匹配位于(M/多行)开头的数字

rcm=re.compile(r"\d+$")# 对于’$’来说，没有使用M选项，它将匹配最后一个行尾的数字，即’678’，加上以后，就能匹配三个行尾的数字456 012和678了.
print re.compile(r"\d+$",re.M).findall(s6) # 
```
